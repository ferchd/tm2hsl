# tm2hsl

[![CI](https://github.com/ferchd/tm2hsl/workflows/CI/badge.svg)](https://github.com/ferchd/tm2hsl/actions)
[![Go Report Card](https://goreportcard.com/badge/github.com/ferchd/tm2hsl)](https://goreportcard.com/report/github.com/ferchd/tm2hsl)
[![GoDoc](https://godoc.org/github.com/ferchd/tm2hsl?status.svg)](https://godoc.org/github.com/ferchd/tm2hsl)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

**tm2hsl** is a compiler that transforms TextMate syntax grammars into optimized HSL bytecode, revolutionizing language support in code editors.

## Vision

The **tm2hsl** project aims to create a modern and scalable infrastructure for programming language support in code editors, strictly separating language definition from the editor engine. Instead of the editor interpreting complex grammars at runtime (as happens today with TextMate in VSCode, Atom or Sublime), tm2hsl proposes **compiling those grammars once** into an optimized binary format called **HSL bytecode**, which the editor then executes directly, fast and deterministic. The central idea is to treat language grammars as code that is compiled, not as configurations that are dynamically interpreted.

The main objective of the project is to drastically reduce latency, memory consumption and runtime complexity of the editor, while at the same time allowing scaling to hundreds or thousands of languages without each one adding additional load to the system. tm2hsl acts as an external tool (CLI) that takes as input existing language definitions —mainly TextMate grammars, along with snippets, configurations and tests— and transforms them into a stable, validated binary artifact ready to run. The editor never sees TextMate, never executes arbitrary regexes and never makes semantic decisions on the fly; it only loads previously compiled bytecode.

To integrate with an editor, the editor must include an **HSL lexical engine**, a small and deterministic piece that knows how to execute the bytecode. This engine does not need to understand human language or the original grammar; it only needs to be able to interpret simple instructions: evaluate precompiled patterns, transition between states, emit tokens with scopes and handle incremental execution by lines. The engine must support state cache per line, incremental execution after edits and be completely free of I/O, GC or dynamic dependencies, ideally written in a low-level language like Zig or Rust.

The HSL bytecode generated is a compact binary format, memory-mappable, versioned and stable, designed to be read sequentially by the engine. It contains tables of states, rules, precompiled patterns, lexical actions and minimal metadata (language id, version, capabilities). It does not include redundant strings, dynamic structures or complex conditional logic; all costly decisions have already been resolved at compile time by tm2hsl. The bytecode describes an explicit and closed lexical machine, not an abstract grammar.

The inputs to tm2hsl are well-defined language repositories: TextMate grammars (JSON or plist), language configuration files (comments, pairs, indentation), snippets and optionally tokenization tests. The output is one or more `compiled.hsl` files along with metadata that the editor can index and load on demand. tm2hsl validates, normalizes and optimizes everything before generating the bytecode, so any error or ambiguity is detected outside the editor, not in the user's runtime.

A key point of the project is **layer separation**: HSL only covers lexical analysis (highlighting, scopes, superficial structure), while other critical parts of the editor, such as semantic analysis, autocompletion or diagnostics, integrate through **LSP or other services**. The editor can expose the token stream generated by HSL to the LSP as auxiliary information, but the LSP remains independent and asynchronous. This reduces the LSP load and improves perceived latency without coupling both layers.

As a sign of future improvement, the design allows HSL to evolve without breaking the editor: new bytecode versions, new instructions or capabilities can be added (for example, lexical folding, structural tokens) while maintaining backward compatibility. It also opens the door to an ecosystem where languages are distributed as validated binary artifacts, with CI and versioning, instead of loose configurations interpreted on each execution.

In summary, tm2hsl seeks to convert language support into a **compiled infrastructure**, predictable and scalable, where the editor remains simple, fast and stable, and where adding new languages does not imply increasing complexity or runtime cost. It is a technical basis for modern editors that want to go beyond the inherited TextMate model without breaking compatibility with the existing ecosystem.

## Features

- **Ahead-of-time compilation**: Transforms TextMate grammars into optimized HSL bytecode
- **Deterministic execution**: Same input produces same bytecode
- **Massive scalability**: Efficient support for hundreds of languages
- **Layer separation**: Compiled languages vs. execution engine
- **Binary format**: Memory-mappable, versioned, and compact
- **Complete CLI**: Tools for development and testing

## Installation

### Pre-built Binaries

Download binaries from the [releases page](https://github.com/ferchd/tm2hsl/releases).

### From Source

```bash
# Clone the repository
git clone https://github.com/ferchd/tm2hsl.git
cd tm2hsl

# Setup development environment
make dev-setup

# Build the project
make build

# Install globally
make install
```

### Requirements

- Go 1.21 or higher
- Git

## Usage

### Basic Compilation

```bash
# Compile a TextMate grammar
tm2hsl compile --config language.toml --output output.hsl

# Validate without generating bytecode
tm2hsl compile --config language.toml --validate-only
```

### Configuration File

Create a `language.toml`:

```toml
name = "MyLanguage"
scope = "source.mylanguage"
grammar = "grammars/mylanguage.json"

[metadata]
version = "1.0.0"
description = "Support for MyLanguage"
```

## Architecture

```
tm2hsl
├── cmd/tm2hsl/          # Main CLI
├── internal/             # Private code
│   ├── cli/             # Command interface
│   ├── compiler/        # Compilation logic
│   ├── parser/          # TextMate parsing
│   ├── ir/              # Intermediate representation
│   ├── normalizer/      # Grammar normalization
│   ├── optimizer/       # Optimizations
│   ├── codegen/         # Bytecode generation
│   ├── serializer/      # HSL serialization
│   └── config/          # Configuration handling
├── pkg/                 # Public packages
│   ├── hsl/            # HSL bytecode format
│   └── textmate/       # TextMate types
└── docs/               # Documentation
```

### Compilation Flow

1. **Parsing**: Load and validate TextMate grammar (JSON/plist)
2. **Normalization**: Convert to deterministic state machine
3. **IR**: Generate optimized intermediate representation
4. **Optimization**: Apply structural transformations
5. **Bytecode**: Generate HSL binary bytecode
6. **Serialization**: Write final `.hsl` file

## HSL Format

HSL bytecode is a binary format designed for:

- **Sequential execution**: Efficient disk reading
- **Memory-mapping**: Zero-copy loading
- **Versioning**: Forward compatibility
- **Compression**: Optimized and deduplicated tables

### Bytecode Structure

```
HSL Header (64 bytes)
├── Magic: "HSL1"
├── Version: uint16
├── Checksum: uint32
└── Offset table...

String Table
Regex Table
State Table
Rule Table
Scope Table
```



## Contributing

Contributions are welcome! See [CONTRIBUTING.md](CONTRIBUTING.md) for detailed guides.

### Quick Development

```bash
# Setup environment
./scripts/setup-dev.sh

# Iterative development
make          # build + test + lint
make build    # build only
make test     # tests only
```

### Conventional Commits

We use [Conventional Commits](https://conventionalcommits.org/) for messages:

```bash
feat: add support for recursive includes
fix: fix regex lookbehind parsing
docs: update HSL specification
```

## Documentation

- [HSL Specification](docs/HSL_SPEC.md) - Detailed bytecode format
- [Migration Guide](docs/MIGRATION.md) - From TextMate to HSL
- [Internal API](docs/API.md) - Developer reference
- [Examples](examples/) - Sample languages

## Project Status

**Current version**: 0.x (active development)

### Supported (v0)
- `match` rules with basic regex
- `begin`/`end` rules with content
- `contentName` for internal scopes
- `captures` with simple names
- Includes: `$self`, `$base`
- Line and block comments

### Not Supported (future)
- Repository with `#name` references
- Captures in `begin`/`end`
- `while` rules
- Complex back-references
- Advanced lookahead/lookbehind

## License

This project is licensed under Apache License 2.0 - see [LICENSE](LICENSE) for details.

## Acknowledgments

- [TextMate](https://macromates.com/) for the grammar format
- [VSCode](https://code.visualstudio.com/) for popularizing TextMate
- Open source community for inspiration and tools

## Contact

- **Issues**: [GitHub Issues](https://github.com/ferchd/tm2hsl/issues)
- **Discussions**: [GitHub Discussions](https://github.com/ferchd/tm2hsl/discussions)
- **Email**: [fernando@example.com](mailto:fernando@example.com)

---

**tm2hsl**: Compiling languages, accelerating editors.